---
layout: post
title: "리엑트 정리하기- 04번째 시간: 스크롤 판단에 대해"
---

# 오늘은 내가 스크롤 판단을 최적화 한 상황에 대해 정리해보겠듬

**핵심 문제 :** 스크롤 되었는지 판단, 스크롤이 되었다면 **css 변경**

---

## 기존 로직

```js
useEffect(() => {
        const handleScroll = () => {
            const scrolled = window.scrollY > 50;
            setIsScrolled(prev => {
                if (prev !== scrolled) {
                    return scrolled;
                }
                return prev;
            });
        };
        window.addEventListener('scroll', handleScroll);
        return () => window.removeEventListener('scroll', handleScroll);
}, []);
````

---

## 변경한 로직

```js
useEffect(() => {
        const handleScroll =() => {
        const scrolled = window.scrollY > 50
        setIsScrolled(scrolled);
        };

        window.addEventListener('scroll', handleScroll);
        return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

---

## 기존 로직에 대해 설명하자면,

`scrolled`라는 변수에 조건식(**y가 50보다 내려가있는지**)을 바탕으로 **참 거짓 값**이 들어감

이 때 현재값(`prev`)과 비교를 해서 같으면 현재값으로 그대로 두고

다르면 `scrolled` 변수 안에있던 **참 혹은 거짓**이 `setIsScrolled`로 들어감

(`setIsScrolled`는 내가 `useState`으로 만들어준 **isScrolled 값변경함수**임.)

그러면 이제 `setIsScrolled`가 `isScrolled` 값을 입력받은 대로 변환해줌

---

## 조금더 풀어서 설명해보자면

`isScrolled`는 스크롤되어있는지에 대한 값이 들어있는 변수임

만약 **참**이면 현재 스크롤이 되어있는 거고 **거짓**이면 스크롤이 안되어있는

다시말해 **최상단에 위치한 상태**라는 것임

이 변수는 `setIsScrolled`로만 변경해줄수있으며 초기값은 **false**임.
(이게 당연한게 처음 페이지 들어오면 최상단에 있으니까 스크롤 되어있지 않은 상태인거)

이제 `setIsScrolled` 함수내에서 `isScrolled`의 현재까지의 결과 값이 `prev`로 불러 와진거고

`prev`와 `scrolled`의 비교가 일어나는거임.

그래서 둘이 같다면 그대로 `prev`가 유지되는거고

다르다면 `setIsScrolled`에 의해 `isScrolled` 값이 변경되는거임( 또 이 변경된값이 다시 `prev`가 됨 )

---

## 이 코드를 조금더 간결하게 짤 수 있음 ( 변경된 로직 )

`setIsScrolled`안에 있는 조건문을 그냥 `scrolled` 변수로 바꾸는거임

이렇게 되면 `scrolled`가 조건문(`window.scrollY > 50;`)에 의해 바뀌는 순간

그냥 `isScrolled` 안에 **직빵**으로 들어가는거임

---

## 그러면 이런 의문이 들 수 있음

"아니 그럼 그냥 prev 안쓰고 깔끔띠하게 scrolled만 써서 하면되는거아니야?"

어느정도 맞긴함

그런데 위에같이 `prev`를 써서 하는데 **이유가 다 있는 거임**

---

## 이유

1. **스크롤 이벤트는 굉장히 자주 발생하는 이벤트임**
   따라서 한번 스크롤 할때 수십에서 수백번 발생할 수도 있음

그렇게 되면 **불필요한 state 업데이트 호출 시도**가 생길 수 있음

이걸 안생기게하기 위해서 `prev !== scrolled`로 **필터링을 한번 거쳐주는 거임**

이렇게 되면 React가 **불필요한 state 업데이트 호출 시도**를 덜 하게 되서

**성능이 개선될 수 있음**

2. **협업 코드 관점**에서는 '언제 값이 변경 되어야하는지'가 더 **명확**해진다는 장점도 있을 수 있음

---

## 그럼 그냥 prev 써서 할까?

노노 노노놉

상황에 따라 해야함
장단점이 있다 이말이

---

## 정리드감

1. `setIsScrolled(scrolled)`
   -> **코드 단순.** 최적화는 React에 맡김. **불필요한 state 업데이트 호출 시도** 발생 가능

2. `setIsScrolled(prev => prev !== scrolled ? scrolled : prev)`
   -> **코드 복잡.** 조금더 직접 제어. **불필요한 비교 및 업데이트 호출 시도 최소화**

---

## 결론

그런데 내가 하고자하는 스크롤은 그렇게 민감하지도 헤비하지도 않아서 **불필요한 업데이트 시도**가 조금있더라도

**코드의 단순화**가 더 좋음

그리고 실제 1번과 2번 사이의 **체감이 될정도로의 엄청난 차이는 없음.**

웬만한 상황에서는 **1번으로 코드 단순하게 해도 충분할듯**

# SIMPLE IS BEST

---

## 추가 

만약 성능에 **미친듯이 민감한 UI**라면 위의 `prev` 방식으로 부족할 수도 있음
그렇다면
`throttle`이나 `debounce`와 같은 **유틸함수**까지 적용해서

**이벤트의 호출 빈도**를 줄이는 것이 좋음

---

# 끝

